数据结构和算法出现的目的就是解决"快"和"省"的问题，如何让代码运行的更快，更省空间，就要涉及到算法的时间复杂度和空间复杂度分析：

1.时间、空间复杂度分析是算法的精髓，是学习数据结构与算法的基础。

2.通过直接运行一段程序，统计、监控时间空间使用情况的统计方法称为事后统计法，这种方法有很多局限性：
（1）测试结果依赖测试环境，同样的代码在不同的处理器下测试结果不同。
（2）测试结果受数据规模或者数据的特性，所以我们需要一个不受数据规模和数据特性（如有序无序）影响的分析方法。

3.大O 表示法
（1）大O表示法的基本思想是先将每行代码执行的时间假设是一样的，为一个单位时间 unit_time,所有代码的执行时间 T(n) 与每行代码的执行次数 n
成正比。由此得出一个公式 T(n) = O(f(n))  T(n) 表示数据规模为n时的代码执行时间，f(n) 表示代码执行次数的总和，是一个计算的公式。

（2）需要注意的是大O时间复杂度所得出的并不是实际的算法执行时间，而是代表了随着数据规模的增长代码执行时间的变化趋势，所以也叫做渐进时间复
杂度，简称时间复杂度。

（3）复杂度分析技巧：
  *1.只关注循环次数最多的代码，由于大O表示法表示的是一种去随着数据规模变化，代码执行速度的变化趋势，所以只需要记录下最大阶的量级就够了。
  *2.加法法则，多段代码复杂度总和等于其中复杂度量级最大的，如果两段代码的数量规模 分别是不确定的m , n 那么且不能很明显的判断哪个量级更大，
     时间复杂度就是两段相加。
  *3.乘法法则，如果是嵌套型代码，等于嵌套内外代码复杂度的乘积。


（4）一般情况下，只要算法中不存在循环，递归，即使有上万条语句，算法的复杂度也是O(1) 因为一定不会随着数据量n的变化改变算法的执行效率

（5）对数阶是常见但是较难分析的一种例如
   i=1;
   while (i <= n) {
   i = i*2
   }
   只需要计算i = i * 2这行代码执行时间
   循环终止条件是 i<= n 所以只需要看这行代码执行了多少次能达到这个条件
   i= 1 ，2 ， 4 ，8 ...
   i= 2^0 , 2^1 , 2^2 ,2^3 ...2^x   x = 这行代码执行满足退出循环条件的次数  x = log2 n 的对数
   同样 假设 i= 1*3，i*4，得出x = log3 n ,x = log4 n的对数  这样的算法统一表示为 O(logn) 可以完全忽略对数的底数统称为对数阶时间
   复杂度

（6）参考复杂度常见量级图

（7）空间复杂度，同样空间复杂度指的是算法所需的存储空间与数据规模的改变的变化关系，分析比较简单后续具体算法再分析吧



